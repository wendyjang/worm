#화학적 요소(인, 칼륨, 질소, pH) 고려한 매핑, 1마리 ver

import numpy as np
import matplotlib.pyplot as plt


grid_size = 20  # 토양 격자 크기 (20x20)


# 인(P): 4.8 kg/10a (랜덤범위 : 3.84~5.76)
# 칼륨(K): 6.4 kg/10a (랜덤범위 : 5.12~7.68)
# 질소(N): 9.0 kg/10a (랜덤범위 : 7.2~10.8)
# pH: 6.5 (랜덤범위 : 5.5~7.5)

P  = np.random.uniform(3.84, 5.76, size=(grid_size, grid_size))  # 인
K  = np.random.uniform(5.12, 7.68, size=(grid_size, grid_size))  # 칼륨
N  = np.random.uniform(7.2, 10.8, size=(grid_size, grid_size))   # 질소
pH = np.random.uniform(5.5, 7.5, size=(grid_size, grid_size))    # pH


P0  = P.copy()
K0  = K.copy()
N0  = N.copy()
pH0 = pH.copy()


ideal_P  = 4.8   # 인 (kg/10a)
ideal_K  = 6.4   # 칼륨 (kg/10a)
ideal_N  = 9.0   # 질소 (kg/10a)
ideal_pH = 6.5   # pH



def compute_bad_scores():
    # 각 성분별 제곱 오차
    bad_P  = (P  - ideal_P)  ** 2
    bad_K  = (K  - ideal_K)  ** 2
    bad_N  = (N  - ideal_N)  ** 2
    bad_pH = (pH - ideal_pH) ** 2

   
    def normalize(m):
        mmax = m.max()
        if mmax == 0:
            return m
        return m / mmax

    P_norm  = normalize(bad_P)
    K_norm  = normalize(bad_K)
    N_norm  = normalize(bad_N)
    pH_norm = normalize(bad_pH)

 
    total_bad = (P_norm + K_norm + N_norm + pH_norm) / 4.0
    return total_bad


def get_neighbors(r, c):
    moves = [(-1,0), (1,0), (0,-1), (0,1)]
    for dr, dc in moves:
        nr, nc = r + dr, c + dc
        if 0 <= nr < grid_size and 0 <= nc < grid_size:
            yield nr, nc


pos = (0, 0)         # 시작 위치
path = [pos]         # 경로 기록
visited = set([pos]) # 방문 칸 집합


bad0 = compute_bad_scores()

num_steps = 10000

for step in range(num_steps):
    r, c = pos
    bad_score = compute_bad_scores()

    neighbors = list(get_neighbors(r, c))
    unvisited = [p for p in neighbors if p not in visited]

    if not unvisited:
        break

    
    best_pos = None
    best_val = -1.0
    for nr, nc in unvisited:
        if bad_score[nr, nc] > best_val:
            best_val = bad_score[nr, nc]
            best_pos = (nr, nc)

    
    pos = best_pos
    path.append(pos)
    visited.add(pos)

    pr, pc = pos

   
    P[pr, pc]  += 2.4 * (ideal_P  - P[pr, pc])
    K[pr, pc]  += 3.2 * (ideal_K  - K[pr, pc])
    N[pr, pc]  += 4.5 * (ideal_N  - N[pr, pc])
    pH[pr, pc] += 3.25 * (ideal_pH - pH[pr, pc])


    for nr, nc in get_neighbors(pr, pc):
        P[nr, nc]  += 0.8 * (ideal_P  - P[nr, nc])
        K[nr, nc]  += 1 * (ideal_K  - K[nr, nc])
        N[nr, nc]  += 1.5 * (ideal_N  - N[nr, nc])
        pH[nr, nc] += 1 * (ideal_pH - pH[nr, nc])


bad1 = compute_bad_scores()
print("총 이동 스텝 수:", len(path) - 1)
print("서로 다른 칸 수:", len(set(path)))


fig, axes = plt.subplots(1, 3, figsize=(12, 4))

im0 = axes[0].imshow(bad0, cmap='Reds')
axes[0].set_title('초기 bad_score')
plt.colorbar(im0, ax=axes[0])

im1 = axes[1].imshow(bad1, cmap='Reds')
axes[1].set_title('지렁이 이동 후 bad_score')
plt.colorbar(im1, ax=axes[1])

axes[2].imshow(bad1, cmap='Reds')
path_r = [p[0] for p in path]
path_c = [p[1] for p in path]
axes[2].plot(path_c, path_r, marker='o', markersize=1, linewidth=0.25)
axes[2].set_title(f'지렁이 이동 경로 (방문 칸 수={len(path)})')
axes[2].invert_yaxis()

plt.tight_layout()
plt.show()

